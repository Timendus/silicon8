# 10 print chr$(147)
# 100 for py=0 to 21
#   110 for px=0 to 31
#     120 xz = px*3.5/32-2.5
#     130 yz = py*2/22-1
#     140 x = 0
#     150 y = 0
#     160 for i=0 to 14
#       170 if x*x+y*y > 4 then goto 215
#       180 xt = x*x - y*y + xz
#       190 y = 2*x*y + yz
#       200 x = xt
#     210 next i
#     215 i = i-1
#     220 poke 1024+py*40+px,160
#     230 poke 55296+py*40+px,i
#   240 next px
# 260 next py
# 270 for i=0 to 9
#   280 print chr$(17)
# 290 next i

:const scale 8 # 1/2^8
:macro asFixed X Y D {
	vB := X
	:calc remainder { ( ( Y / D ) * ( 1 << scale ) ) & 0xFF }
	vC := remainder
}

# Variables in registers
:alias screenY v8
:alias screenX v9
:alias index vE

# Variables in memory
:const scaledX 0
:const scaledY 2
:const x 4
:const y 6
:const temp1 8
:const temp2 10

: main
  set-monitors
  clear
  screenY := 0
  loop
    screenX := 0
    loop
      calculateScaledX
      calculateScaledY

      # x := 0
      # y := 0
      asFixed 0 0 1 # 0 + 0/1
      vA := x
      store-fixed16
      vA := y
      store-fixed16

      index := 0
      loop
        # temp1 := x * x
        vA := x
        vB := x
        mult-fixed16
        vA := temp1
        store-fixed16

        # temp2 := y * y
        vA := y
        vB := y
        mult-fixed16
        vA := temp2
        store-fixed16

        # Get temp1 + temp2
        vA := temp1
        vB := temp2
        add-fixed16
        if vB >= 4 then jump break-inner-loop

        # temp1 := x*x + y*y + scaledX
        vA := temp1
        store-fixed16 # x * x + y * y was still in vB and vC
        vB := scaledX
        add-fixed16
        vA := temp1
        store-fixed16

        # y := (x+x)*y + scaledY
        # temp2 := 2 * x
        vA := x
        load-fixed16
        vA := temp2
        store-fixed16
        vB := x
        add-fixed16
        store-fixed16
        # temp2 := temp2 * y
        vB := y
        mult-fixed16
        store-fixed16
        # temp2 += scaledY
        vB := scaledY
        add-fixed16
        # y := temp2
        vA := y
        store-fixed16

        # x = temp1
        vA := temp1
        load-fixed16
        vA := x
        store-fixed16

        index += 1
      if index != 15 then again
: break-inner-loop
      draw-pixel
      screenX += 1
    if screenX != 64 then again
    screenY += 1
  if screenY != 32 then again

  # Done
  loop again

: calculateScaledX
  # scaledX := (fixed)screenX
  vA := scaledX
  vB := screenX
  vC := 0
  store-fixed16

  # temp1 := 3.5 / 64
  vA := temp1
  asFixed 0 546875 10000000 # 3.5/64 = 0,0546875 = 0 + 546875/10000000
  store-fixed16

  # scaledX = scaledX * 3.5 / 64
  vA := scaledX
  vB := temp1
  mult-fixed16
  store-fixed16

  # temp1 := 2.5
  vA := temp1
  asFixed 2 5 10 # 2 + 5/10 = 2.5
  store-fixed16

  # scaledX -= 2.5
  vA := scaledX
  vB := temp1
  sub-fixed16
  store-fixed16

  return

: calculateScaledY
  # scaledY := (fixed)screenY
  vA := scaledY
  vB := screenY
  vC := 0
  store-fixed16

  # temp1 := 2 / 32
  vA := temp1
  asFixed 0 625 10000 # 2/32 = 0,0625 = 0 + 625/10000
  store-fixed16

  # scaledX = scaledX * 2 / 32
  vA := scaledY
  vB := temp1
  mult-fixed16
  store-fixed16

  # temp1 := 1
  vA := temp1
  asFixed 1 0 1 # 1 + 0/1 = 1
  store-fixed16

  # scaledY -= 1
  vA := scaledY
  vB := temp1
  sub-fixed16
  store-fixed16

  return

: draw-pixel
  # Select colour by changing planes based on `index`
  v0 := 0xF0
  v0 += index
  i := set-plane-smc
  save v0
: set-plane-smc
  0x00 0x01
  # Draw the pixel
  i := pixel
  sprite screenX screenY 1
  return

: pixel
  0b10000000
  0b10000000
  0b10000000
  0b10000000





: mult-fixed16
	mult-int16
	# Do a poor man's (but fast!) result >> 8
	vC := vB
	vB := vD
	return

# This basically implements this function:
#
# function mult(a,b) {
#   let res = 0;
#   if ( b > a ) {
#     const t = a;
#     a = b;
#     b = t;
#   }
#   while(b) {
#     if ( b & 1 ) res += a;
#     b >>= 1;
#     a <<= 1;
#   }
#   return res;
# }
#
# The result is really 24-bits (vD, vB, vC) so we can use it for fixed point too
: mult-int16
	i := variable-storage
	i += vA
	load v1
	v3 := v0
	v4 := v1
	i := variable-storage
	i += vB
	load v1
	vD := 0
	vB := 0
	vC := 0
	v5 := 0

	# Swap operands if second operand is (significantly) larger than first
	if v0 > v3 begin
		v6 := v0
		v7 := v1
		v0 := v3
		v1 := v4
		v3 := v6
		v4 := v7
	end

	loop
		# while ( b )
		v2 := v0
		v2 |= v1
		if v2 == 0 then return

		# if ( b & 1 ) res += a
		v2 := 1
		v2 &= v1
		if v2 == 1 begin
			vC += v4
			vB += vF
			vD += vF
			vB += v3
			vD += vF
			vD += v5
		end

		# b >>= 1
		v1 >>= v1
		v0 >>= v0
		if vF == 1 then v1 += 128

		# a <<= 1
		v5 <<= v5
		v3 <<= v3
		v5 += vF  # if vF == 1 then v5 += 1
		v4 <<= v4
		v3 += vF  # if vF == 1 then v3 += 1
	again

: add-fixed16
: add-int16
  i := variable-storage
  i += vA
  load v1
  v3 := v0
  v4 := v1
  i := variable-storage
  i += vB
  load v1
  vC := v4
  vC += v1
  vB := vF
  vB += v3
  vB += v0
  return

: sub-fixed16
: sub-int16
	i := variable-storage
	i += vA
	load v1
	v3 := v0
	v4 := v1
	i := variable-storage
	i += vB
	load v1
	vC := v4
	vC -= v1
	vB := v3
	if vF == 0 then vB -= 1
	vB -= v0
	return

: store-fixed16
: store-int16
  i := variable-storage
  i += vA
  v0 := vB
  v1 := vC
  save v1
  return

: load-fixed16
: load-int16
  i := variable-storage
  i += vA
  load v1
  vB := v0
  vC := v1
  return

: fixed16-to-int16
	load-int16
	vC := vB
	vB := 0
	jump store-int16

: int16-to-fixed16
	load-int16
	vB := vC
	vC := 0
	jump store-int16

:org 0x400

: variable-storage

# Space here

:org 0x0800

: set-monitors
  :monitor variable-storage 30
  return
